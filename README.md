# 读者写者问题
[toc]
## 1.要求
在Linux环境下，创建一个进程，此进程包含n个线程。用这n个线程来表示n个读者或写者。每个线程按相应测试数据文件(后面有介绍)的要求进行读写操作。用信号量机制分别实现读者优先和写者优先的读者-写者问题。
读者-写者问题的读写操作限制(仅读者优先或写者优先)：
1. 写-写互斥，即不能有两个写者同时进行写操作。
2. 读-写互斥，即不能同时有一个线程在读，而另一个线程在写。
3. 读-读允许，即可以有一个或多个读者在读。

## 2.概念
读者优先：当有读者在等待队列里等待时，写者进程不能开始  
写者优先：当有写者在等待队列里等待时，读者进程不能开始  

## 3.输入文件格式
测试数据文件包括n行测试数据，分别描述创建的n个线程是读者还是写者，以及读写操作的开始时间和持续时间。每行测试数据包括四个字段，各个字段间用空格分隔。第一字段为一个正整数，表示线程序号。第二字段表示相应线程角色，R表示读者，W表示写者。第三字段为一个正数，表示读写操作的开始时间：线程创建后，延迟相应时间(单位为秒)后发出对共享资源的读写申请。第四字段为一个正数，表示读写操作的持续时间。当线程读写申请成功后，开始对共享资源的读写操作，该操作持续相应时间后结束，并释放共享资源
下面是一个测试数据文件的例子：
```
1　R　3　　5
2　W　4　　5
3　R　5　　2
4　R　6　　5
5　W　7　　3
```

## 4.程序编译
公平竞争
```shell
gcc fairCompetition.c -o fairCompetition.out -l pthread
```
读者优先
```shell
gcc readFirst.c -o readFirst.out -l pthread
```
写者优先
```shell
gcc writeFirst.c -o writeFirst.out -l pthread
```
或直接运行build.sh
## 5.测试样例
### 正确性检验
#### 公平竞争
输入
```shell
./fairCompetition.out < data
```
输出
```shell
[00秒]创建进程1
[00秒]创建进程2
[00秒]创建进程3
[00秒]创建进程4
[00秒]创建进程5
[03秒]读者进程1等待读取
[03秒]读者进程1开始读取
[04秒]写者进程2等待写入
[05秒]读者进程3等待读取
[05秒]读者进程3开始读取
[06秒]读者进程4等待读取
[06秒]读者进程4开始读取
[07秒]写者进程5等待写入
[07秒]读者进程3读取结束
[08秒]读者进程1读取结束
[11秒]读者进程4读取结束
[11秒]写者进程2开始写入
[16秒]写者进程2写入结束
[16秒]写者进程5开始写入
[19秒]写者进程5写入结束
```
#### 读者优先
输入
```shell
./readFirst.out < data
```
输出
```
[00秒]创建进程1
[00秒]创建进程2
[00秒]创建进程3
[00秒]创建进程4
[00秒]创建进程5
[03秒]读者进程1等待读取
[03秒]读者进程1开始读取
[04秒]写者进程2等待写入
[05秒]读者进程3等待读取
[05秒]读者进程3开始读取
[06秒]读者进程4等待读取
[06秒]读者进程4开始读取
[07秒]写者进程5等待写入
[07秒]读者进程3读取结束
[08秒]读者进程1读取结束
[11秒]读者进程4读取结束
[11秒]写者进程2开始写入
[16秒]写者进程2写入结束
[16秒]写者进程5开始写入
[19秒]写者进程5写入结束
```
#### 写者优先
输入
```shell
./writeFirst.out < data
```
输出
```
[00秒]创建进程1
[00秒]创建进程2
[00秒]创建进程3
[00秒]创建进程4
[00秒]创建进程5
[03秒]读者进程1等待读取
[03秒]读者进程1开始读取
[04秒]写者进程2等待写入
[05秒]读者进程3等待读取
[06秒]读者进程4等待读取
[07秒]写者进程5等待写入
[08秒]读者进程1读取结束
[08秒]写者进程2开始写入
[13秒]写者进程2写入结束
[13秒]写者进程5开始写入
[16秒]读者进程3开始读取
[16秒]读者进程4开始读取
[16秒]写者进程5写入结束
[18秒]读者进程3读取结束
[21秒]读者进程4读取结束
```
### 检验读者优先或写者优先正确性
```shell
./readFirst.out < dataDist
```
样例输出
（三种算法的不同之处在05秒和12秒）

|公平竞争|读者优先|写者优先|
|:-|:-|:-|
|[00 秒]创建进程 1|[00 秒]创建进程 1|[00 秒]创建进程 1|
|[00 秒]创建进程 2|[00 秒]创建进程 2|[00 秒]创建进程 2|
|[00 秒]创建进程 3|[00 秒]创建进程 3|[00 秒]创建进程 3|
|[00 秒]创建进程 4|[00 秒]创建进程 4|[00 秒]创建进程 4|
|[00 秒]创建进程 5|[00 秒]创建进程 5|[00 秒]创建进程 5|
|[00 秒]创建进程 6|[00 秒]创建进程 6|[00 秒]创建进程 6|
|[01 秒]写者进程 1 等待写入|[01 秒]写者进程 1 等待写入|[01 秒]写者进程 1 等待写入
|[01 秒]写者进程 1 开始写入|[01 秒]写者进程 1 开始写入|[01 秒]写者进程 1 开始写入
|[02 秒]写者进程 2 等待写入|[02 秒]写者进程 2 等待写入|[02 秒]写者进程 2 等待写入
|[03 秒]读者进程 3 等待读取|[03 秒]读者进程 3 等待读取|[03 秒]读者进程 3 等待读取
|[05 秒]写者进程 1 写入结束|[05 秒]读者进程 3 开始读取|[05 秒]写者进程 1 写入结束
|[05 秒]写者进程 2 开始写入|[05 秒]写者进程 1 写入结束|[05 秒]写者进程 2 开始写入
|[06 秒]写者进程 2 写入结束|[06 秒]读者进程 3 读取结束|[06 秒]写者进程 2 写入结束
|[06 秒]读者进程 3 开始读取|[06 秒]写者进程 2 开始写入|[06 秒]读者进程 3 开始读取
|[07 秒]读者进程 3 读取结束|[07 秒]写者进程 2 写入结束|[07 秒]读者进程 3 读取结束
|[08 秒]写者进程 4 等待写入|[08 秒]写者进程 4 等待写入|[08 秒]写者进程 4 等待写入
|[08 秒]写者进程 4 开始写入|[08 秒]写者进程 4 开始写入|[08 秒]写者进程 4 开始写入
|[09 秒]读者进程 5 等待读取|[09 秒]读者进程 5 等待读取|[09 秒]读者进程 5 等待读取
|[10 秒]写者进程 6 等待写入|[10 秒]写者进程 6 等待写入|[10 秒]写者进程 6 等待写入
|[12 秒]写者进程 4 写入结束|[12 秒]读者进程 5 开始读取|[12 秒]写者进程 4 写入结束
|[12 秒]读者进程 5 开始读取|[12 秒]写者进程 4 写入结束|[12 秒]写者进程 6 开始写入
|[13 秒]读者进程 5 读取结束|[13 秒]读者进程 5 读取结束|[13 秒]写者进程 6 写入结束
|[13 秒]写者进程 6 开始写入|[13 秒]写者进程 6 开始写入|[13 秒]读者进程 5 开始读取
|[14 秒]写者进程 6 写入结束|[14 秒]写者进程 6 写入结束|[14 秒]读者进程 5 读取结束
## 6.伪代码
### 公平竞争
在没有特别的优先级情况下，读者写者公平竞争。进程之间通过wrt的锁保证临界区访问的互斥性，先获得wrt锁的进程先执行。
#### 读者
```c
wait(mutex);
++reader_count;
if(reader_count == 1) {
  wait(&wrt);
}
signal(mutex);

// read

wait(mutex);
--reader_count;
if(reader_count == 0) {
  signal(&wrt);
}
signal(mutex);
```
#### 写者
```c
wait(&wrt);

// write

signal(&wrt);
```
### 读者优先
读者优先和写者优先需要引入一个状态变量state，表明当前系统的状态。需要用到的几个状态量如下：
- mutex：保证reader_count, writer_count, state变量访问的互斥性
- Sig_read：允许读的信号量
- Sig_wrt：允许写的信号量
#### 读者
```c
wait(mutex);
++reader_count;
if(state == s_waiting || state == s_reading) {
  signal(Sig_read);
  state = s_reading;
}
signal(mutex);

// read

wait(mutex);
--reader_count;
if(reader_count == 0) {
  if(writer_count != 0) {
    signal(Sig_wrt);
    state = s_writing;
  } else {
    state = s_waiting;
  }
}
signal(mutex);
```
#### 写者
```c
wait(mutex);
++writer_count;
if(state == s_waiting) {
  signal(Sig_wrt);
  state = s_writing;
}
signal(mutex);

// write

wait(mutex);
--writer_count;
if(reader_count != 0) {
  signal(Sig_read);
  state = s_reading;
} else if(writer_count != 0) {
  signal(Sig_wrt);
  state = s_writing;
} else {
  state = s_waiting;
}
signal(mutex);
```
### 写者优先
#### 读者
```c
wait(mutex);
++reader_count;
if(state == s_waiting 
|| (state == s_reading && writer_count == 0)) {
  signal(Sig_read);
  state = s_reading;
}
signal(mutex);

// read

wait(mutex);
--reader_count;
if(writer_count != 0) {
  // 有读者在等待
  sem_post(Sig_wrt);
  state = s_writing;
} else if(reader_count == 0) {
  // 等待队列为空
  state = s_waiting;
}
signal(mutex);
```
#### 写者
```c
wait(mutex);
++writer_count;
if(state == s_waiting) {
  signal(Sig_wrt);
  state = s_writing;
}
signal(mutex);

// write

wait(mutex);
--writer_count;
if(writer_count != 0) {
  signal(Sig_wrt);
  state = s_writing;
} else if(reader_count != 0) {
  for(int i=0; i!=reader_count; ++i) {
    signal(Sig_read);
  }
  state = s_reading;
} else {
  state = s_waiting;
}
signal(mutex);
```
